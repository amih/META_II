////////////////////////////////////
version 1, toy, just a demo...
no validation, just field types, no sizes. No keys, no indexes...
CREATE TABLE addressbook (
  accountname name,
  id int,
  first_name string,
  yearofbirth int,
)
//////////////////////////////////////
#include <eosio/eosio.hpp>
using namespace eosio;
class [[eosio::contract("addressbook")]] addressbook : public eosio::contract {
  public:
  private:
};
//////////////////////////////////////
.SYNTAX SQL2EOSIO

SQL2EOSIO = HEADER 'CREATE' 'TABLE' ID {  } '(' 
    FIELD $ FIELD 
')';

FIELD = ID FIELDTYPE ',';

FIELDTYPE = 'name'  /
            'int'   /
            'string';
.END
////////////////////////////////////
CREATE TABLE addressbook (
  accountname name,
  id int(28),
  first_name string(50),
  last_name string(50),
  street string(50),
  city string(20),
  state string(2),
  email string(70),
  yearofbirth int,
  PRIMARY KEY ('id'),
  UNIQUE KEY 'email_UNIQUE' ('email')
)
////////////////////////////////////
.SYNTAX PROGRAM
PROGRAM = '.SYNTAX' ID {.LB \t 'ADR ' * \n}
          $(PR / COMMENT)
          '.TOKENS'
          $(TR / COMMENT)
          '.END' {\t 'END' \n};

[ parsing rule definition ]
PR = ID {.LB * \n} '=' EX1 ';' {\t 'R' \n};

[ token rule definition ]
TR = ID {.LB * \n} ':' TX1 ';' {\t 'R' \n};

[ comment definition ]
COMMENT = '[' CMLINE ']' {.LB ';' * \n};

[ parsing expressions ]
EX1 = EX2 $('/' {\t 'BT L'# \n} EX2 )
      {.LB 'L'# \n};

EX2 = (EX3 {\t 'BF L'# \n} / OUTPUT)
      $(EX3 {\t 'BE' \n} / OUTPUT)
      {.LB 'L'# \n};

EX3 = ID        {\t 'CLL '* \n}        /
      STRING    {\t 'TST ' 39 * 39 \n} /
      '(' EX1 ')'                            /
      '.EMPTY'  {\t 'SET' \n}          /
      '.LITCHR' {\t 'LCH' \n}          /
      '$' {.LB 'L'# \n} EX3 {\t 'BT L'# \n} {\t 'SET' \n};

[ output expressions ]
OUTPUT = '{' $OUT1 '}';

OUT1 = '*'     {\t 'CI' \n}          /
       STRING  {\t 'CL ' 39 * 39 \n} /
       NUMBER  {\t 'CC '* \n}        /
       '#'     {\t 'GN' \n}          /
       '\n'    {\t 'NL' \n}          /
       '.LB'   {\t 'LB' \n}          /
       '\t'    {\t 'TB' \n}          /
       '.LM+'  {\t 'LMI' \n}         /
       '.LM-'  {\t 'LMD' \n}         ;

[ token expressions ]
TX1 = TX2 $('/' {\t 'BT T'# \n} TX2) 
      {.LB 'T'# \n};

TX2 = TX3 {\t 'BF T'# \n}
      $(TX3 {\t 'RF' \n} )
      {.LB 'T'# \n};

TX3 = ( '.TOKEN'         {\t 'TFT' \n} /
        '.DELTOK'        {\t 'TFF' \n} /
        '$' {.LB 'T'# \n} TX3 {\t 'BT T'# \n} ) 
                         {\t 'SET' \n}               /
      '.ANYBUT(' CX1 ')' {\t 'NOT' \n \t 'SCN' \n} /
      '.ANY(' CX1 ')'    {\t 'SCN' \n}               /
      ID                 {\t 'CLL ' * \n}            /
      '(' TX1 ')'                                          ;

[ character expressions ]            
CX1 = CX2 $('!' {\t 'BT C'# \n} CX2) {.LB 'C'# \n} ;
CX2 = CX3 (':' {\t 'CGE ' * \n} {\t 'BF D'# \n} 
               CX3
               {\t 'CLE ' * \n} {.LB 'D' # \n} /
           .EMPTY {\t 'CE ' * \n}                   ) ;
CX3 = NUMBER / SQUOTE .LITCHR ;

[ token definitions ]
.TOKENS

PREFIX : $.ANY(32!9!13!10) ;
ID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;
NUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;
STRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;
ALPHA  : .ANY('A:'Z!'a:'z) ;
DIGIT  : .ANY('0:'9) ;
SQUOTE : PREFIX .ANY('') ;
CMLINE : .TOKEN $.ANYBUT(10!13!']) .DELTOK ;

.END
//////////////////////////////////////
//////////////////////////////////////
//////////////////////////////////////
CREATE TABLE addressbook (
  accountname name,
  id int(28),
  first_name string(50),
  last_name string(50),
  street string(50),
  city string(20),
  state string(2),
  email string(70),
  yearofbirth int,
  PRIMARY KEY ('id'),
  UNIQUE KEY 'email_UNIQUE' ('email')
)
SELECT * FROM addressbook WHERE yearofbirth>3;
INSERT INTO addressbook VALUES();
////////////////////////////////////////////////////////////////////////////////
#include <eosio/eosio.hpp>
using namespace eosio;
class [[eosio::contract("addressbook")]] addressbook : public eosio::contract {
  public:
  private:
};
////////////////////////////////////////////////////////////////////////////////
#include <eosio/eosio.hpp>
using namespace eosio;
class [[eosio::contract("addressbook")]] addressbook : public eosio::contract {
public:
  addressbook(name receiver, name code,  datastream<const char*> ds): contract(receiver, code, ds) {}
  [[eosio::action]] void upsert(name user, std::string first_name, std::string last_name, std::string street, std::string city, std::string state) {
    require_auth( user );
    address_index addresses( get_self(), get_first_receiver().value );
    auto iterator = addresses.find(user.value);
    if( iterator == addresses.end() )
    {
      addresses.emplace(user, [&]( auto& row ) {
       row.key = user;
       row.first_name = first_name;
       row.last_name = last_name;
       row.street = street;
       row.city = city;
       row.state = state;
      });
    } else {
      addresses.modify(iterator, user, [&]( auto& row ) {
        row.key = user;
        row.first_name = first_name;
        row.last_name = last_name;
        row.street = street;
        row.city = city;
        row.state = state;
      });
    }
  }
  [[eosio::action]]
  void erase(name user) {
    require_auth(user);
    address_index addresses( get_self(), get_first_receiver().value);
    auto iterator = addresses.find(user.value);
    check(iterator != addresses.end(), "Record does not exist");
    addresses.erase(iterator);
  }
private:
  struct [[eosio::table]] person {
    name key;
    std::string first_name;
    std::string last_name;
    std::string street;
    std::string city;
    std::string state;
    uint64_t primary_key() const { return key.value; }
  };
  using address_index = eosio::multi_index<"people"_n, person>;
};
//////////////////////////////////////
// TODO: add validations on insert, enforce string size limits from the create table definition
// handle multiple indexes, prepare select methods in c++ based on them, also insert/update/upsert/delete?
//////////////////////////////////////
//////////////////////////////////////
//////////////////////////////////////
//////////////////////////////////////
//////////////////////////////////////
//////////////////////////////////////
compiled using ca12.
i01 = `
.SYNTAX SQL2EOSIO

SQL2EOSIO = HEADER 'CREATE' 'TABLE' TABLENAME '('
  FIELD $ FIELD
')'
FOOTER;

HEADER = {
  '#include <eosio/eosio.hpp>\n'
  'using namespace eosio;\n'
};

FOOTER = {
  '  public:\n'
  '  private:\n'
  '};\n'
};

TABLENAME = ID {
'class [[eosio::contract("'*'")]] '*' : public eosio::contract {\n'
};

FIELD = ID FIELDTYPE ',';

FIELDTYPE = 'name'  /
            'int'   /
            'string';




[ token expressions ]
TX1 = TX2 $('/' {\t 'BT T'# \n} TX2) 
      {.LB 'T'# \n};

TX2 = TX3 {\t 'BF T'# \n}
      $(TX3 {\t 'RF' \n} )
      {.LB 'T'# \n};

TX3 = ( '.TOKEN'         {\t 'TFT' \n} /
        '.DELTOK'        {\t 'TFF' \n} /
        '$' {.LB 'T'# \n} TX3 {\t 'BT T'# \n} ) 
                         {\t 'SET' \n}               /
      '.ANYBUT(' CX1 ')' {\t 'NOT' \n \t 'SCN' \n} /
      '.ANY(' CX1 ')'    {\t 'SCN' \n}               /
      ID                 {\t 'CLL ' * \n}            /
      '(' TX1 ')'                                          ;

[ character expressions ]            
CX1 = CX2 $('!' {\t 'BT C'# \n} CX2) {.LB 'C'# \n} ;
CX2 = CX3 (':' {\t 'CGE ' * \n} {\t 'BF D'# \n} 
               CX3
               {\t 'CLE ' * \n} {.LB 'D' # \n} /
           .EMPTY {\t 'CE ' * \n}                   ) ;
CX3 = NUMBER / SQUOTE .LITCHR ;

[ token definitions ]
.TOKENS

PREFIX : $.ANY(32!9!13!10) ;
ID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;
NUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;
STRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;
ALPHA  : .ANY('A:'Z!'a:'z) ;
DIGIT  : .ANY('0:'9) ;
SQUOTE : PREFIX .ANY('') ;
CMLINE : .TOKEN $.ANYBUT(10!13!']) .DELTOK ;

.END
`;
c01 = `	ADR SQL2EOSIO
SQL2EOSIO
	CLL HEADER
	BF L1
	TST 'CREATE'
	BE
	TST 'TABLE'
	BE
	CLL TABLENAME
	BE
	TST '('
	BE
	CLL FIELD
	BE
L2
	CLL FIELD
	BT L2
	SET
	BE
	TST ')'
	BE
	CLL FOOTER
	BE
L1
L3
	R
HEADER
	CL '#include <eosio/eosio.hpp>\n'
	CL 'using namespace eosio;\n'
L4
L5
	R
FOOTER
	CL '  public:\n'
	CL '  private:\n'
	CL '};\n'
L6
L7
	R
TABLENAME
	CLL ID
	BF L8
	CL 'class [[eosio::contract("'
	CI
	CL '")]] '
	CI
	CL ' : public eosio::contract {\n'
L8
L9
	R
FIELD
	CLL ID
	BF L10
	CLL FIELDTYPE
	BE
	TST ','
	BE
L10
L11
	R
FIELDTYPE
	TST 'name'
	BF L12
L12
	BT L13
	TST 'int'
	BF L14
L14
	BT L13
	TST 'string'
	BF L15
L15
L13
	R
; token expressions 
TX1
	CLL TX2
	BF L16
L17
	TST '/'
	BF L18
	TB
	CL 'BT T'
	GN
	NL
	CLL TX2
	BE
L18
L19
	BT L17
	SET
	BE
	LB
	CL 'T'
	GN
	NL
L16
L20
	R
TX2
	CLL TX3
	BF L21
	TB
	CL 'BF T'
	GN
	NL
L22
	CLL TX3
	BF L23
	TB
	CL 'RF'
	NL
L23
L24
	BT L22
	SET
	BE
	LB
	CL 'T'
	GN
	NL
L21
L25
	R
TX3
	TST '.TOKEN'
	BF L26
	TB
	CL 'TFT'
	NL
L26
	BT L27
	TST '.DELTOK'
	BF L28
	TB
	CL 'TFF'
	NL
L28
	BT L27
	TST '$'
	BF L29
	LB
	CL 'T'
	GN
	NL
	CLL TX3
	BE
	TB
	CL 'BT T'
	GN
	NL
L29
L27
	BF L30
	TB
	CL 'SET'
	NL
L30
	BT L31
	TST '.ANYBUT('
	BF L32
	CLL CX1
	BE
	TST ')'
	BE
	TB
	CL 'NOT'
	NL
	TB
	CL 'SCN'
	NL
L32
	BT L31
	TST '.ANY('
	BF L33
	CLL CX1
	BE
	TST ')'
	BE
	TB
	CL 'SCN'
	NL
L33
	BT L31
	CLL ID
	BF L34
	TB
	CL 'CLL '
	CI
	NL
L34
	BT L31
	TST '('
	BF L35
	CLL TX1
	BE
	TST ')'
	BE
L35
L31
	R
; character expressions 
CX1
	CLL CX2
	BF L36
L37
	TST '!'
	BF L38
	TB
	CL 'BT C'
	GN
	NL
	CLL CX2
	BE
L38
L39
	BT L37
	SET
	BE
	LB
	CL 'C'
	GN
	NL
L36
L40
	R
CX2
	CLL CX3
	BF L41
	TST ':'
	BF L42
	TB
	CL 'CGE '
	CI
	NL
	TB
	CL 'BF D'
	GN
	NL
	CLL CX3
	BE
	TB
	CL 'CLE '
	CI
	NL
	LB
	CL 'D'
	GN
	NL
L42
	BT L43
	SET
	BF L44
	TB
	CL 'CE '
	CI
	NL
L44
L43
	BE
L41
L45
	R
CX3
	CLL NUMBER
	BF L46
L46
	BT L47
	CLL SQUOTE
	BF L48
	LCH
	BE
L48
L47
	R
; token definitions 
PREFIX
T49
	CE 32
	BT C50
	CE 9
	BT C50
	CE 13
	BT C50
	CE 10
C50
	SCN
	BT T49
	SET
	BF T51
T51
T52
	R
ID
	CLL PREFIX
	BF T53
	TFT
	SET
	RF
	CLL ALPHA
	RF
T54
	CLL ALPHA
	BF T55
T55
	BT T56
	CLL DIGIT
	BF T57
T57
T56
	BT T54
	SET
	RF
	TFF
	SET
	RF
T53
T58
	R
NUMBER
	CLL PREFIX
	BF T59
	TFT
	SET
	RF
	CLL DIGIT
	RF
T60
	CLL DIGIT
	BT T60
	SET
	RF
	TFF
	SET
	RF
T59
T61
	R
STRING
	CLL PREFIX
	BF T62
	CE 39
C63
	SCN
	RF
	TFT
	SET
	RF
T64
	CE 13
	BT C65
	CE 10
	BT C65
	CE 39
C65
	NOT
	SCN
	BT T64
	SET
	RF
	TFF
	SET
	RF
	CE 39
C66
	SCN
	RF
T62
T67
	R
ALPHA
	CGE 65
	BF D68
	CLE 90
D68
	BT C69
	CGE 97
	BF D70
	CLE 122
D70
C69
	SCN
	BF T71
T71
T72
	R
DIGIT
	CGE 48
	BF D73
	CLE 57
D73
C74
	SCN
	BF T75
T75
T76
	R
SQUOTE
	CLL PREFIX
	BF T77
	CE 39
C78
	SCN
	RF
T77
T79
	R
CMLINE
	TFT
	SET
	BF T80
T81
	CE 10
	BT C82
	CE 13
	BT C82
	CE 93
C82
	NOT
	SCN
	BT T81
	SET
	RF
	TFF
	SET
	RF
T80
T83
	R
	END`;
now, copy output to code and test using this:

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// simplest!
.SYNTAX SQL2EOSIO

SQL2EOSIO = HEADER 'CREATE' 'TABLE'  '('
')'
FOOTER;

HEADER = {
  '#include <eosio/eosio.hpp>\n'
  'using namespace eosio;\n'
};

FOOTER = {
  '  public:\n'
  '  private:\n'
  '};\n'
};

TABLENAME = ID {
'class [[eosio::contract("'*'")]] '*' : public eosio::contract {\n'
};

FIELD = ID FIELDTYPE ',';

FIELDTYPE = 'name'  /
            'int'   /
            'string';




[ token expressions ]
TX1 = TX2 $('/' {\t 'BT T'# \n} TX2) 
      {.LB 'T'# \n};

TX2 = TX3 {\t 'BF T'# \n}
      $(TX3 {\t 'RF' \n} )
      {.LB 'T'# \n};

TX3 = ( '.TOKEN'         {\t 'TFT' \n} /
        '.DELTOK'        {\t 'TFF' \n} /
        '$' {.LB 'T'# \n} TX3 {\t 'BT T'# \n} ) 
                         {\t 'SET' \n}               /
      '.ANYBUT(' CX1 ')' {\t 'NOT' \n \t 'SCN' \n} /
      '.ANY(' CX1 ')'    {\t 'SCN' \n}               /
      ID                 {\t 'CLL ' * \n}            /
      '(' TX1 ')'                                          ;

[ character expressions ]            
CX1 = CX2 $('!' {\t 'BT C'# \n} CX2) {.LB 'C'# \n} ;
CX2 = CX3 (':' {\t 'CGE ' * \n} {\t 'BF D'# \n} 
               CX3
               {\t 'CLE ' * \n} {.LB 'D' # \n} /
           .EMPTY {\t 'CE ' * \n}                   ) ;
CX3 = NUMBER / SQUOTE .LITCHR ;

[ token definitions ]
.TOKENS

PREFIX : $.ANY(32!9!13!10) ;
ID     : PREFIX .TOKEN ALPHA $(ALPHA/DIGIT) .DELTOK ;
NUMBER : PREFIX .TOKEN DIGIT $DIGIT .DELTOK ;
STRING : PREFIX .ANY(39) .TOKEN $.ANYBUT(13!10!39) .DELTOK .ANY(39) ;
ALPHA  : .ANY('A:'Z!'a:'z) ;
DIGIT  : .ANY('0:'9) ;
SQUOTE : PREFIX .ANY('') ;
CMLINE : .TOKEN $.ANYBUT(10!13!']) .DELTOK ;

.END
/////// simpler..... using the ancient c03.
.SYNTAX PROGRAM
PROGRAM = 'CREATE' 'TABLE' .ID .OUT(
  'class [[eosio::contract("' * '")]] addressbook : public eosio::contract {'
).,
.END

then, copy output to code and test...
